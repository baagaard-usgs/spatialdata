#!/usr/bin/env python
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "spatialdata/geocoords/CoordSys.hh"
#include "spatialdata/geocoords/CSCart.hh"
#include "spatialdata/geocoords/CSGeo.hh"
#include "spatialdata/geocoords/CSGeoLocalCart.hh"
#include "spatialdata/geocoords/CSGeoProj.hh"
#include "spatialdata/geocoords/Projector.hh"
#include "spatialdata/geocoords/Converter.hh"

#include <stdexcept>
#include <Python.h>
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)

cdef void* ptrFromHandle(obj):
  """Extract pointer from PyCObject."""
  return PyCObject_AsVoidPtr(obj.handle)

cdef extern from "stdlib.h":
    ctypedef unsigned long size_t
    void* malloc(size_t size)
    void free(void* mem)

# ----------------------------------------------------------------------
cdef class CoordSys:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for object base type

  def __init__(self):
    """Constructor."""
    self.handle = None
    self.thisptr = NULL
    self.name = "spatialdata_geocoords_CoordSys"
    return


  def initialize(self):
    """Initialize the coordinate system."""
    # create shim for method 'initialize'
    #embed{ void CoordSys_initialize(void* pObj)
    try {
      ((spatialdata::geocoords::CoordSys*) pObj)->initialize();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed

    CoordSys_initialize(self.thisptr)
    return


  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    # create shim for destructor
    #embed{ void CoordSys_destructor(void* pObj)
    spatialdata::geocoords::CoordSys* pCS =
      (spatialdata::geocoords::CoordSys*) pObj;
    delete pCS;
    #}embed
    return PyCObject_FromVoidPtr(self.thisptr, CoordSys_destructor)


  property spaceDim:
    def __set__(self, ndims):
      """Set number of dimensions for coordinates."""
      # create shim for method 'spaceDim'
      #embed{ void CoordSys_spaceDim_set(void* pObj, int ndims)
      try {
        ((spatialdata::geocoords::CoordSys*) pObj)->setSpaceDim(ndims);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      CoordSys_spaceDim_set(self.thisptr, ndims)

    def __get__(self):
      """Get number of dimensions for coordinates."""
      # create shim for method 'spaceDim'
      #embed{ int CoordSys_spaceDim_get(void* pObj)
      int dim = 0;
      try {
        dim = ((spatialdata::geocoords::CoordSys*) pObj)->spaceDim();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return dim;
      #}embed
      return CoordSys_spaceDim_get(self.thisptr)


# ----------------------------------------------------------------------
cdef class CSCart(CoordSys):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* CSCart_constructor()
      return (void*)(new spatialdata::geocoords::CSCart);
    #}embed

    CoordSys.__init__(self)
    self.thisptr = CSCart_constructor()
    self.handle = self._createHandle()
    return


  property toMeters:
    def __set__(self, scale):
      """Set scale factor for converting coordinates to SI units (meters)."""
      # create shim for method 'toMeters'
      #embed{ void CSCart_toMeters_set(void* pObj, double scale)
      try {
        ((spatialdata::geocoords::CSCart*) pObj)->toMeters(scale);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      CSCart_toMeters_set(self.thisptr, scale)

    def __get__(self):
      """Get scale factor for converting coordinates to SI units (meters)."""
      # create shim for method 'toMeters'
      #embed{ double CSCart_toMeters_get(void* pObj)
      double value = 0;
      try {
        value = ((spatialdata::geocoords::CSCart*) pObj)->toMeters();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return value;
      #}embed
      return CSCart_toMeters_get(self.thisptr)


# ----------------------------------------------------------------------
cdef class CSGeo(CoordSys):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* CSGeo_constructor()
      return (void*)(new spatialdata::geocoords::CSGeo);
    #}embed

    CoordSys.__init__(self)
    self.thisptr = CSGeo_constructor()
    self.handle = self._createHandle()
    return


  property ellipsoid:
    def __set__(self, name):
      """Set reference ellipsoid."""
      # create shim for method 'ellipsoid'
      #embed{ void CSGeo_ellipsoid_set(void* pObj, char* name)
      try {
        ((spatialdata::geocoords::CSGeo*) pObj)->ellipsoid(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      CSGeo_ellipsoid_set(self.thisptr, name)

    def __get__(self):
      """Fet reference ellipsoid."""
      # create shim for method 'ellipsoid'
      #embed{ char* CSGeo_ellipsoid_get(void* pObj)
      char* name = 0;
      try {      
        name = (char*) ((spatialdata::geocoords::CSGeo*) pObj)->ellipsoid();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return name;
      #}embed
      return CSGeo_ellipsoid_get(self.thisptr)


  property datumHoriz:
    def __set__(self, name):
      """Set horizontal datum."""
      # create shim for method 'datumHoriz'
      #embed{ void CSGeo_datumHoriz_set(void* pObj, char* name)
      try {
        ((spatialdata::geocoords::CSGeo*) pObj)->datumHoriz(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      CSGeo_datumHoriz_set(self.thisptr, name)
      
    def __get__(self):
      """Get horizontal datum."""
      # create shim for method 'datumHoriz'
      #embed{ char* CSGeo_datumHoriz_get(void* pObj)
      char* name = 0;
      try {
        name = (char*) ((spatialdata::geocoords::CSGeo*) pObj)->datumHoriz();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return name;
      #}embed
      return CSGeo_datumHoriz_get(self.thisptr)


  property datumVert:
    def __set__(self, name):
      """Set vertical datum."""
      # create shim for method 'datumVert'
      #embed{ void CSGeo_datumVert_set(void* pObj, char* name)
      try {
        ((spatialdata::geocoords::CSGeo*) pObj)->datumVert(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      CSGeo_datumVert_set(self.thisptr, name)

    def __get__(self):
      """Get vertical datum."""
      # create shim for method 'datumVert'
      #embed{ char* CSGeo_datumVert_get(void* pObj)
      char* name = 0;
      try {
        name = (char*) ((spatialdata::geocoords::CSGeo*) pObj)->datumVert();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return name;
      #}embed
      return CSGeo_datumVert_get(self.thisptr)


  property isGeocentric:
    def __set__(self, flag):
      """Set geocentric flag."""
      # create shim for method 'isGeocentric'
      #embed{ void CSGeo_isGeocentric_set(void* pObj, int flag)
      try {
        ((spatialdata::geocoords::CSGeo*) pObj)->isGeocentric(flag);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      CSGeo_isGeocentric_set(self.thisptr, flag)

    def __get__(self):
      """Get geocentric flag."""
      # create shim for method 'isGeocentric'
      #embed{ int CSGeo_isGeocentric_get(void* pObj)
      int value = 0;
      try {
        value = ((spatialdata::geocoords::CSGeo*) pObj)->isGeocentric();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return value;
      #}embed
      return CSGeo_isGeocentric_get(self.thisptr)
      

  property toMeters:
    def __set__(self, scale):
      """Set factor to convert Cartesian coordinates to meters."""
      # create shim for method 'toMeters'
      #embed{ void CSGeo_toMeters_set(void* pObj, double scale)
      try {
        ((spatialdata::geocoords::CSGeo*) pObj)->toMeters(scale);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      CSGeo_toMeters_set(self.thisptr, scale)

    def __get__(self):
      """Get factor to convert Cartesian coordinates to meters."""
      # create shim for method 'toMeters'
      #embed{ double CSGeo_toMeters_get(void* pObj)
      double value = 0.0;
      try {
        value = ((spatialdata::geocoords::CSGeo*) pObj)->toMeters();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return value;
      #}embed
      return CSGeo_toMeters_get(self.thisptr)


# ----------------------------------------------------------------------
cdef class CSGeoLocalCart(CSGeo):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* CSGeoLocalCart_constructor()
      return (void*)(new spatialdata::geocoords::CSGeoLocalCart);
    #}embed

    CSGeo.__init__(self)
    self.thisptr = CSGeoLocalCart_constructor()
    self.handle = self._createHandle()
    return


  def origin(self, lon, lat, elev):
    """Set origin of local cartesian coordinate system."""
    # create shim for method 'origin'
    #embed{ void CSGeoLocalCart_origin(void* pObj, double lon, double lat, double elev)
    try {
      ((spatialdata::geocoords::CSGeoLocalCart*) pObj)->origin(lon, lat, elev);
    } catch (const std::exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.what()));
    } catch (...) {
    PyErr_SetString(PyExc_RuntimeError,
                    "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    CSGeoLocalCart_origin(self.thisptr, lon, lat, elev)


  def getOrigin(self):
    """Get origin of local cartesian coordinate system."""
    # create shim for method 'origin'
    #embed{ void CSGeoLocalCart_getOrigin(void* pObj, double* pLon, double* pLat, double* pElev)
    try {
      ((spatialdata::geocoords::CSGeoLocalCart*) pObj)->origin(pLon, pLat, pElev);
    } catch (const std::exception& err) {
    PyErr_SetString(PyExc_RuntimeError,
                    const_cast<char*>(err.what()));
    } catch (...) {
    PyErr_SetString(PyExc_RuntimeError,
                    "Caught unknown C++ exception.");
    } // try/catch
    #}embed
    cdef double lon, lat, elev
    CSGeoLocalCart_getOrigin(self.thisptr, &lon, &lat, &elev)
    return (lon, lat, elev)


# ----------------------------------------------------------------------
cdef class CSGeoProj(CSGeo):

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* CSGeoProj_constructor()
      return (void*)(new spatialdata::geocoords::CSGeoProj);
    #}embed

    CSGeo.__init__(self)
    self.thisptr = CSGeoProj_constructor()
    self.handle = self._createHandle()
    return


  property projector:
    def __set__(self, proj):
      """Set projector."""
      # create shim for method 'projector'
      #embed{ void CSGeoProj_projector(void* pObj, void* pProjObj)
      try {
        const spatialdata::geocoords::Projector* pProj =
        (spatialdata::geocoords::Projector*) pProjObj;
        ((spatialdata::geocoords::CSGeoProj*) pObj)->projector(*pProj);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      if not proj.name == "spatialdata_geocoords_Projector":
        raise TypeError, \
              "Argument must be extension module type 'Projector'."
      CSGeoProj_projector(self.thisptr, ptrFromHandle(proj))


# ----------------------------------------------------------------------
cdef class Projector:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for type of object

  def __init__(self):
    """Constructor."""
    # create shim for constructor
    #embed{ void* Projector_constructor()
    return (void*)(new spatialdata::geocoords::Projector);
    #}embed

    self.thisptr = Projector_constructor()
    self.handle = self._createHandle()
    self.name = "spatialdata_geocoords_Projector"
    return


  property projection:
    def __set__(self, name):
      """Set projection."""
      # create shim for method 'projection'
      #embed{ void Projector_projection_set(void* pObj, char* name)
      try {
        ((spatialdata::geocoords::Projector*) pObj)->projection(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Projector_projection_set(self.thisptr, name)

    def __get__(self):
      """Get projection."""
      # create shim for method 'projection'
      #embed{ char* Projector_projection_get(void* pObj)
      char* name = 0;
      try {
        name = (char*) ((spatialdata::geocoords::Projector*) pObj)->projection();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return name;
      #}embed
      return Projector_projection_get(self.thisptr)


  property units:
    def __set__(self, name):
      """Set units of projection."""
      # create shim for method 'units'
      #embed{ void Projector_units_set(void* pObj, char* name)
      try {
        ((spatialdata::geocoords::Projector*) pObj)->units(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Projector_units_set(self.thisptr, name)

    def __get__(self):
      """Get units of projection."""
      # create shim for method 'units'
      #embed{ char* Projector_units_get(void* pObj)
      char* name = 0;
      try {
        name = (char*) ((spatialdata::geocoords::Projector*) pObj)->units();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return name;
      #}embed
      return Projector_units_get(self.thisptr)

  property projOptions:
    def __set__(self, options):
      """Set proj.4 options for projector."""
      # create shim for method 'projOptions'
      #embed{ void Projector_projOptions_set(void* pObj, char* options)
      try {
        ((spatialdata::geocoords::Projector*) pObj)->projOptions(options);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed
      Projector_projOptions_set(self.thisptr, options)

    def __get__(self):
      """Set proj.4 options for projector."""
      # create shim for method 'projOptions'
      #embed{ char* Projector_projOptions_get(void* pObj)
      char* name = 0;
      try {
        name = (char*) ((spatialdata::geocoords::Projector*) pObj)->projOptions();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return name;
      #}embed
      return Projector_projOptions_get(self.thisptr)


  def initialize(self, csGeo):
    """Initialize projector."""
    # create shim for method 'initialize'
    #embed{ void Projector_initialize(void* pObj, void* pCSObj)
    try {
      const spatialdata::geocoords::CoordSys* pCS =
        (spatialdata::geocoords::CoordSys*) pCSObj;
      const spatialdata::geocoords::CSGeo* pCSGeo =
        dynamic_cast<const spatialdata::geocoords::CSGeo*>(pCS);
      ((spatialdata::geocoords::Projector*) pObj)->initialize(*pCSGeo);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    if not csGeo.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument 'csGeo' must be extension module type 'CSGeo'."

    Projector_initialize(self.thisptr, ptrFromHandle(csGeo))
    return
  

  def project(self, lonlat):
    """Project geographic coordinates."""
    # create shim for method 'project'
    #embed{ void Projector_project(void* pObj, double* pX, double* pY, double lon, double lat)
    try {
      ((spatialdata::geocoords::Projector*) pObj)->project(pX, pY, lon, lat);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    cdef double x
    cdef double y
    npts = len(lonlat)
    xy = []
    for i from 0 <= i < npts:
      lon = lonlat[i][0]
      lat = lonlat[i][1]
      Projector_project(self.thisptr, &x, &y, lon, lat)
      xy.append([x, y])
    return xy
  

  def invproject(self, xy):
    """Get geographics coordinates for projected location."""
    # create shim for method 'invproject'
    #embed{ void Projector_invproject(void* pObj, double* pLon, double* pLat, double x, double y)
    try {
      ((spatialdata::geocoords::Projector*) pObj)->invproject(pLon, pLat, x, y);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch      
    #}embed

    cdef double lon
    cdef double lat
    npts = len(xy)
    lonlat = []
    for i from 0 <= i < npts:
      x = xy[i][0]
      y = xy[i][1]
      Projector_invproject(self.thisptr, &lon, &lat, x, y)
      lonlat.append([lon, lat])
    return lonlat
  

  def _createHandle(self):
    """Wrap pointer to C++ object in PyCObject."""
    # create shim for destructor
    #embed{ void Projector_destructor(void* pObj)
    spatialdata::geocoords::Projector* pProj =
      (spatialdata::geocoords::Projector*) pObj;
    delete pProj;
    #}embed
    return PyCObject_FromVoidPtr(self.thisptr, Projector_destructor)


# ----------------------------------------------------------------------
# create shim for Converter method 'convert'
#embed{ void CppConverter_convert(double* coords, int numLocs, int numDims, void* pCSDestObj, void* pCSSrcObj)
try {
  spatialdata::geocoords::CoordSys* pCSDest =
    (spatialdata::geocoords::CoordSys*) pCSDestObj;
  spatialdata::geocoords::CoordSys* pCSSrc =
    (spatialdata::geocoords::CoordSys*) pCSSrcObj;
  spatialdata::geocoords::Converter::convert(coords, numLocs, numDims,
                                             pCSDest, pCSSrc);
} catch (const std::exception& err) {
  PyErr_SetString(PyExc_RuntimeError,
                  const_cast<char*>(err.what()));
} catch (...) {
  PyErr_SetString(PyExc_RuntimeError,
                  "Caught unknown C++ exception.");
} // try/catch  
#}embed

def Converter_convert(coordsSrc, csDest, csSrc):
  """Convert coordinates from source coordinate system 'csSrc' to
  destination coordinate system 'csDest'."""

  import spatialdata.utils.simplearray
  coordsSrc = spatialdata.utils.simplearray.objAsSimpleArray(coordsSrc)
  if not coordsSrc.isCompatible(nd=2,
                                simpletype="double",
                                writeable=True,
                                contiguous=True,
                                notswapped=True):
    raise TypeError, \
          "Argument 'coordsSrc' must be a contiguous, writeable, 2-D array " \
          "of type double."

  if not csDest.name == "spatialdata_geocoords_CoordSys":
    raise TypeError, \
          "Argument 'csDest' must be extension module type 'CSGeo'."
  if not csSrc.name == "spatialdata_geocoords_CoordSys":
    raise TypeError, \
          "Argument 'csSrc' must be extension module type 'CSGeo'."

  (numLocs, numDims) = coordsSrc.shape

  cdef double* vals
  vals = <double*> PyCObject_AsVoidPtr(coordsSrc.data)
  CppConverter_convert(vals, numLocs, numDims,
                       ptrFromHandle(csDest), ptrFromHandle(csSrc))
  return


# End of file 
