#!/usr/bin/env python
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "spatialdata/spatialdb/SpatialDB.hh"
#include "spatialdata/spatialdb/SimpleDB.hh"
#include "spatialdata/spatialdb/SimpleIO.hh"
#include "spatialdata/spatialdb/SimpleIOAscii.hh"
#include "spatialdata/spatialdb/SimpleDBTypes.hh"
#include "spatialdata/spatialdb/GravityField.hh"
#include "spatialdata/spatialdb/UniformDB.hh"
#include "spatialdata/spatialdb/CompositeDB.hh"
#include "spatialdata/spatialdb/SCECCVMH.hh"

#include "spatialdata/geocoords/CoordSys.hh"

#include <stdexcept>
#include <Python.h>
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)


cdef extern from "stdlib.h":
  ctypedef unsigned long size_t
  void* malloc(size_t size)
  void free(void* mem)
  void strcpy(char*, char*)


cdef void* ptrFromHandle(obj):
  """
  Extract pointer from PyCObject.
  """
  return PyCObject_AsVoidPtr(obj.handle)

cdef double* doubleArray(size):
  """
  Allocate C++ double array.
  """
  # create shim
  #embed{ double* doubleArray_cpp(int size)
  double* result = (size > 0) ? new double[size] : 0;
  return result;
  #}embed
  return doubleArray_cpp(size)


cdef float* floatArray(size):
  """
  Allocate C++ float array.
  """
  # create shim
  #embed{ float* floatArray_cpp(int size)
  float* result = (size > 0) ? new float[size] : 0;
  return result;
  #}embed
  return floatArray_cpp(size)


cdef int* intArray(size):
  """
  Allocate C++ int array.
  """
  # create shim
  #embed{ int* intArray_cpp(int size)
  int* result = (size > 0) ? new int[size] : 0;
  return result;
  #}embed
  return intArray_cpp(size)


# ----------------------------------------------------------------------
cdef void SpatialDB_destructor(void* obj):
  """
  Destroy SpatialDB object.
  """
  # create shim for destructor
  #embed{ void SpatialDB_destructor_cpp(void* pObj)
  spatialdata::spatialdb::SpatialDB* pDB =
    (spatialdata::spatialdb::SpatialDB*) pObj;
  delete pDB;
  #}embed
  SpatialDB_destructor_cpp(obj)
  return

cdef class SpatialDB:

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "spatialdata_spatialdb_SpatialDB"
    return


  property label:
    def __set__(self, name):
      """
      Set label of spatial database.
      """
      # create shim for method 'label'
      #embed{ void SpatialDB_label_set(void* pObj, char* name)
      try {
        ((spatialdata::spatialdb::SpatialDB*) pObj)->label(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed

      SpatialDB_label_set(self.thisptr, name)

    def __get__(self):
      """
      Get label of spatial database.
      """
      # create shim for method 'label'
      #embed{ char* SpatialDB_label_get(void* pObj)
      char* label = 0;
      try {
        label = (char*) ((spatialdata::spatialdb::SpatialDB*) pObj)->label();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return label;
      #}embed

      return SpatialDB_label_get(self.thisptr)

      
  def open(self):
    """
    Open database and prepare for querying.
    """
    # create shim for method 'open'
    #embed{ void SpatialDB_open(void* pObj)
    try {
      ((spatialdata::spatialdb::SpatialDB*) pObj)->open();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed

    SpatialDB_open(self.thisptr)
    return


  def close(self):
    """
    Close the database.
    """
    # create shim for method 'close'
    #embed{ void SpatialDB_close(void* pObj)
    try {
      ((spatialdata::spatialdb::SpatialDB*) pObj)->close();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed

    SpatialDB_close(self.thisptr)
    return


  def queryVals(self, names):
    """
    Set values to be returned by queries.
    """
    # create shim for method 'queryVals'
    #embed{ void SpatialDB_queryVals(void* pObj, char** names, int numVals)
    try {
      ((spatialdata::spatialdb::SpatialDB*) pObj)->queryVals((const char**) names, numVals);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed

    cdef char** pNames
    pNames = NULL
    numVals = len(names)
    if numVals > 0:
      pNames = <char**> malloc(numVals*sizeof(char*))
    for i from 0 <= i < numVals:
      strsize = len(names[i])
      pNames[i] = <char*> malloc(1+strsize*sizeof(char))
      tmp = names[i]
      strcpy(pNames[i], tmp)

    SpatialDB_queryVals(self.thisptr, pNames, numVals)

    # memory cleanup
    for i from 0 <= i < numVals:
      free(<void*> pNames[i])
    free(<void*> pNames)
    
    return


  def query(self, locs, cs, nvals):
    """
    Query db to get values at locations.
    """
    # create shim for method 'query'
    #embed{ int SpatialDB_query(void* pObj, double* vals, int nvals, double* coords, int spaceDim, void* csObj)
    int err = 0;
    try {
      spatialdata::geocoords::CoordSys* pCS =
        (spatialdata::geocoords::CoordSys*) csObj;
        err = ((spatialdata::spatialdb::SpatialDB*) pObj)->query(vals, nvals,
                                                            coords, spaceDim,
                                                            pCS);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return err;
    #}embed

    import spatialdata.utils.simplearray
    locs = spatialdata.utils.simplearray.objAsSimpleArray(locs)
    if not locs.isCompatible(nd=2,
                             simpletype="double",
                             contiguous=True,
                             notswapped=True):
      raise TypeError, \
            "Argument 'locs' must be a contiguous, 2-D array of type double."

    if not cs.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument 'cs' must be extension module type 'CoordSys'."
    if nvals < 1:
      raise TypeError, \
              "Argument 'nvals' must be a positive integer."

    (nlocs, spaceDim) = locs.shape
    
    cdef double* pLocs
    pLocs = <double*> PyCObject_AsVoidPtr(locs.data)

    cdef double* pVals
    pVals = doubleArray(nlocs*nvals)

    cdef int* pErr
    pErr = <int*> intArray(nlocs)

    cdef double* valbuffer
    valbuffer = <double*> malloc(nvals*sizeof(double))

    for iloc from 0 <= iloc < nlocs:
      pErr[iloc] = SpatialDB_query(self.thisptr, valbuffer, nvals,
                                  &pLocs[spaceDim*iloc], spaceDim,
                                  ptrFromHandle(cs))
      for ival from 0 <= ival < nvals:
        pVals[nvals*iloc+ival] = valbuffer[ival]
    free(<void*> valbuffer)

    dims = [nlocs, nvals]
    import spatialdata.utils.simplearray
    pValsObj = PyCObject_FromVoidPtr(pVals, NULL);
    pErrObj = PyCObject_FromVoidPtr(pErr, NULL);
    return (spatialdata.utils.simplearray.SimpleCppArray(pValsObj, dims, "double"),
            spatialdata.utils.simplearray.SimpleCppArray(pErrObj, [nlocs], "int"))


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, SpatialDB_destructor)


# ----------------------------------------------------------------------
cdef class SimpleDB(SpatialDB):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* SimpleDB_constructor()
      return (void*)(new spatialdata::spatialdb::SimpleDB);
    #}embed

    SpatialDB.__init__(self)
    self.thisptr = SimpleDB_constructor()
    self.handle = self._createHandle()
    return


  def queryType(self, name):
    """
    Set query type.
    """
    # create shim for method 'queryType'
    #embed{ void SimpleDB_queryType(void* pObj, char* name)
    spatialdata::spatialdb::SimpleDB::QueryEnum queryType =
      spatialdata::spatialdb::SimpleDB::NEAREST;
    if (0 == strcasecmp(name, "nearest"))
      queryType = spatialdata::spatialdb::SimpleDB::NEAREST;
    else if (0 == strcasecmp(name, "linear"))
      queryType = spatialdata::spatialdb::SimpleDB::LINEAR;
    ((spatialdata::spatialdb::SimpleDB*) pObj)->queryType(queryType);
    #}embed

    if not (name.lower() == "nearest" or name.lower() == "linear"):
      raise ValueError, "Couldn't parse query type '%s' into a known type" \
            "type of query. Accepted values are 'nearest' and 'linear'." \
            % name

    SimpleDB_queryType(self.thisptr, name)
    return


  def ioHandler(self, handle):
    """
    Set the I/O handler.
    """
    # create shim for method 'ioHandler'
    #embed{ void SimpleDB_ioHandler(void* pObj, void* pHandlerObj)
    spatialdata::spatialdb::SimpleIO* pHandler =
      (spatialdata::spatialdb::SimpleIO*) pHandlerObj;
    ((spatialdata::spatialdb::SimpleDB*) pObj)->ioHandler(pHandler);
    #}embed

    if not handle.name == "spatialdata_spatialdb_SimpleIO":
      raise TypeError, \
            "Argument 'handle' must be extension module type 'SimpleIO'."

    SimpleDB_ioHandler(self.thisptr, ptrFromHandle(handle))
    return


# ----------------------------------------------------------------------
cdef void SimpleIO_destructor(void* obj):
  """
  Destructor SimplIO object.
  """
  # create shim for destructor
  #embed{ void SimpleIO_destructor_cpp(void* pObj)
  spatialdata::spatialdb::SimpleIO* pIO =
    (spatialdata::spatialdb::SimpleIO*) pObj;
  delete pIO;
  #}embed
  SimpleIO_destructor_cpp(obj)
  return


cdef class SimpleIO:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for type of object

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "spatialdata_spatialdb_SimpleIO"
    return


  def filename(self, name):
    """
    Set filename for database.
    """
    # create shim for method 'filename'
    #embed{ void SimpleIO_filename(void* pObj, char* name)
    ((spatialdata::spatialdb::SimpleIO*) pObj)->filename(name);
    #}embed

    SimpleIO_filename(self.thisptr, name)
    return


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, SimpleIO_destructor)


# ----------------------------------------------------------------------
cdef class SimpleIOAscii(SimpleIO):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* SimpleIOAscii_constructor()
      return (void*)(new spatialdata::spatialdb::SimpleIOAscii);
    #}embed

    SimpleIO.__init__(self)
    self.thisptr = SimpleIOAscii_constructor()
    self.handle = self._createHandle()
    return


  def write(self, names, units, dataObj, spaceDim, dataDim, cs):
    """
    Write database to file.
    """
    # create shim for method 'write'
    #embed{ void SimpleIOAscii_write(void* pObj, char** names, char** units, double* data, int numLocs, int spaceDim, int numValues, int dataDim, void* pCSObj)
    spatialdata::spatialdb::SimpleDB::DataStruct* pData =
      new spatialdata::spatialdb::SimpleDB::DataStruct;
    pData->data = data;

    pData->valNames = new std::string[numValues];
    pData->valUnits = new std::string[numValues];
    for (int iValue=0; iValue < numValues; ++iValue) {
      pData->valNames[iValue] = names[iValue];
      pData->valUnits[iValue] = units[iValue];
    } // for
    pData->numLocs = numLocs;
    pData->numVals = numValues;
    pData->dataDim = dataDim;
    pData->spaceDim = spaceDim;

    spatialdata::geocoords::CoordSys* pCS =
      (spatialdata::geocoords::CoordSys*) pCSObj;  
    ((spatialdata::spatialdb::SimpleIOAscii*) pObj)->write(*pData, pCS);
    delete[] pData->valNames;
    delete[] pData->valUnits;
    delete pData; pData = 0;
    #}embed

    
    import spatialdata.utils.simplearray
    data = spatialdata.utils.simplearray.objAsSimpleArray(dataObj)
    if not data.isCompatible(nd=2,
                             simpletype="double",
                             contiguous=True,
                             notswapped=True):
      raise TypeError, \
            "Argument 'dataObj' must be a contiguous, 2-D array of type double."
    numValues = len(names)
    if not (numValues == len(units)):
      raise ValueError, \
            "Arguments 'names' and 'values' must have the same length."
    (numLocs, totalDim) = data.shape
    if totalDim != numValues + spaceDim:
      raise ValueError, \
            "'dataObj' not compatible with number of values and spaceDim."
    if not cs.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument 'cs' must be extension module type 'CoordSys'."

    cdef double* dataArray
    dataArray = <double*> PyCObject_AsVoidPtr(data.data)

    cdef char** namesArray
    cdef char** unitsArray
    namesArray = NULL
    unitsArray = NULL
    if numValues > 0:
      namesArray = <char**> malloc(numValues*sizeof(char*))
      unitsArray = <char**> malloc(numValues*sizeof(char*))
    for i from 0 <= i < numValues:
      strsize = len(names[i])
      namesArray[i] = <char*> malloc(1+strsize*sizeof(char))
      tmp = names[i] # KLUDGE??
      strcpy(namesArray[i], tmp)

      strsize = len(units[i])
      unitsArray[i] = <char*> malloc(1+strsize*sizeof(char))
      tmp = units[i] # KLUDGE??
      strcpy(unitsArray[i], tmp)
      
    SimpleIOAscii_write(self.thisptr,
                        namesArray, unitsArray, dataArray,
                        numLocs, spaceDim, numValues, dataDim,
                        ptrFromHandle(cs))
    for i from 0 <= i < numValues:
      free(<void*> namesArray[i])
      free(<void*> unitsArray[i])
    free(<void*> namesArray)
    free(<void*> unitsArray)
    return


# ----------------------------------------------------------------------
cdef class GravityField(SpatialDB):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* GravityField_constructor()
      return (void*)(new spatialdata::spatialdb::GravityField);
    #}embed

    SpatialDB.__init__(self)
    self.thisptr = GravityField_constructor()
    self.handle = self._createHandle()
    return


  def gravityDir(self, up):
    """
    Set direction of gravitational body force.
    """
    # create shim for method 'gravityDir'
    #embed{ void GravityField_gravityDir(void* pObj, double x, double y, double z)
    assert(0 != pObj);
    ((spatialdata::spatialdb::GravityField*) pObj)->gravityDir(x, y, z);
    #}embed
    if len(up) != 3:
      raise ValueError("Up direction must be a 3 component list or tuple.")
    (x, y, z) = map(float, up)

    GravityField_gravityDir(self.thisptr, x, y, z)
    return


  def gravAcceleration(self, value):
    """
    Set gravitational acceleration.
    """
    # create shim for method 'gravAcceleration'
    #embed{ void GravityField_gravAcceleration(void* pObj, double value)
    assert(0 != pObj);
    ((spatialdata::spatialdb::GravityField*) pObj)->gravAcceleration(value);
    #}embed

    GravityField_gravAcceleration(self.thisptr, value)
    return


# ----------------------------------------------------------------------
cdef class UniformDB(SpatialDB):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* UniformDB_constructor()
      return (void*)(new spatialdata::spatialdb::UniformDB);
    #}embed

    SpatialDB.__init__(self)
    self.thisptr = UniformDB_constructor()
    self.handle = self._createHandle()
    return


  def setData(self, names, values):
    """
    Set the data in the spatial database.
    """
    # create shim for method 'setData'
    #embed{ void UniformDB_setData(void* pObj, char** names, double* values, int size)
    assert(0 != pObj);
    ((spatialdata::spatialdb::UniformDB*) pObj)->setData(
      const_cast<const char**>(names), values, size);
    #}embed

    cdef char** namesArray
    cdef double* valuesArray
    namesArray = NULL
    valuesArray = NULL
    numValues = len(names)
    assert(numValues == len(values))
    if numValues > 0:
      namesArray = <char**> malloc(numValues*sizeof(char*))
      valuesArray = <double*> malloc(numValues*sizeof(double))
    for i from 0 <= i < numValues:
      strsize = len(names[i])
      namesArray[i] = <char*> malloc(1+strsize*sizeof(char))
      tmp = names[i] # KLUDGE??
      strcpy(namesArray[i], tmp)

      valuesArray[i] = values[i]
      
    UniformDB_setData(self.thisptr, namesArray, valuesArray, numValues)

    for i from 0 <= i < numValues:
      free(<void*> namesArray[i])
    free(<void*> namesArray)
    free(<void*> valuesArray)
    return


# ----------------------------------------------------------------------
cdef class CompositeDB(SpatialDB):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* CompositeDB_constructor()
      return (void*)(new spatialdata::spatialdb::CompositeDB);
    #}embed

    SpatialDB.__init__(self)
    self.thisptr = CompositeDB_constructor()
    self.handle = self._createHandle()
    return


  def dbA(self, db, names):
    """
    Set database A information.
    """
    # create shim for method 'dbA'
    #embed{ void CompositeDB_dbA(void* pObj, void* objDB, char** names, int size)
    assert(0 != pObj);
    assert(0 != objDB);
    spatialdata::spatialdb::SpatialDB* db =
      (spatialdata::spatialdb::SpatialDB*) objDB;
    ((spatialdata::spatialdb::CompositeDB*) pObj)->dbA(db,
      const_cast<const char**>(names), size);
    #}embed

    if db.name != "spatialdata_spatialdb_SpatialDB":
      raise TypeError("Argument 'db' must be extension module type 'SpatialDB'")

    cdef char** namesArray
    namesArray = NULL
    numValues = len(names)
    if numValues > 0:
      namesArray = <char**> malloc(numValues*sizeof(char*))
    for i from 0 <= i < numValues:
      strsize = len(names[i])
      namesArray[i] = <char*> malloc(1+strsize*sizeof(char))
      tmp = names[i] # KLUDGE??
      strcpy(namesArray[i], tmp)
      
    CompositeDB_dbA(self.thisptr, ptrFromHandle(db), namesArray, numValues)

    for i from 0 <= i < numValues:
      free(<void*> namesArray[i])
    free(<void*> namesArray)
    return


  def dbB(self, db, names):
    """
    Set database B information.
    """
    # create shim for method 'dbB'
    #embed{ void CompositeDB_dbB(void* pObj, void* objDB, char** names, int size)
    assert(0 != pObj);
    assert(0 != objDB);
    spatialdata::spatialdb::SpatialDB* db =
      (spatialdata::spatialdb::SpatialDB*) objDB;
    ((spatialdata::spatialdb::CompositeDB*) pObj)->dbB(db,
      const_cast<const char**>(names), size);
    #}embed

    if db.name != "spatialdata_spatialdb_SpatialDB":
      raise TypeError("Argument 'db' must be extension module type 'SpatialDB'")

    cdef char** namesArray
    namesArray = NULL
    numValues = len(names)
    if numValues > 0:
      namesArray = <char**> malloc(numValues*sizeof(char*))
    for i from 0 <= i < numValues:
      strsize = len(names[i])
      namesArray[i] = <char*> malloc(1+strsize*sizeof(char))
      tmp = names[i] # KLUDGE??
      strcpy(namesArray[i], tmp)
      
    CompositeDB_dbB(self.thisptr, ptrFromHandle(db), namesArray, numValues)

    for i from 0 <= i < numValues:
      free(<void*> namesArray[i])
    free(<void*> namesArray)
    return


# ----------------------------------------------------------------------
cdef class SCECCVMH(SpatialDB):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* SCECCVMH_constructor()
      return (void*)(new spatialdata::spatialdb::SCECCVMH);
    #}embed

    SpatialDB.__init__(self)
    self.thisptr = SCECCVMH_constructor()
    self.handle = self._createHandle()
    return


  def dataDir(self, dir):
    """
    Set the data directory for SCEC CVM-H data files..
    """
    # create shim for method 'dataDir'
    #embed{ void SCECCVMH_dataDir(void* pObj, char* dir)
    assert(0 != pObj);
    ((spatialdata::spatialdb::SCECCVMH*) pObj)->dataDir(dir);
    #}embed

    SCECCVMH_dataDir(self.thisptr, dir)
    return


  def squash(self, flag, limit):
    """
    Set squashed topography/bathymetry flag and minimum elevation of 
    squashing.
    """
    # create shim for method 'squash'
    #embed{ void SCECCVMH_squash(void* pObj, int flag, double limit)
    assert(0 != pObj);
    ((spatialdata::spatialdb::SCECCVMH*) pObj)->squash(flag, limit);
    #}embed

    SCECCVMH_squash(self.thisptr, flag, limit)
    return


# End of file 
