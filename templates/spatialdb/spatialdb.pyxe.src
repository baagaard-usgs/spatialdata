#!/usr/bin/env python
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "spatialdata/spatialdb/SpatialDB.hh"
#include "GeoGridVelModel.hh"

#include "spatialdata/geocoords/CoordSys.hh"

#include <stdexcept>
#include <Python.h>
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)


cdef extern from "stdlib.h":
  ctypedef unsigned long size_t
  void* malloc(size_t size)
  void free(void* mem)
  void strcpy(char*, char*)


cdef void* ptrFromHandle(obj):
  """
  Extract pointer from PyCObject.
  """
  return PyCObject_AsVoidPtr(obj.handle)

cdef double* doubleArray(size):
  """
  Allocate C++ double array.
  """
  # create shim
  #embed{ double* doubleArray_cpp(int size)
  double* result = (size > 0) ? new double[size] : 0;
  return result;
  #}embed
  return doubleArray_cpp(size)


cdef float* floatArray(size):
  """
  Allocate C++ float array.
  """
  # create shim
  #embed{ float* floatArray_cpp(int size)
  float* result = (size > 0) ? new float[size] : 0;
  return result;
  #}embed
  return floatArray_cpp(size)


cdef int* intArray(size):
  """
  Allocate C++ int array.
  """
  # create shim
  #embed{ int* intArray_cpp(int size)
  int* result = (size > 0) ? new int[size] : 0;
  return result;
  #}embed
  return intArray_cpp(size)


# ----------------------------------------------------------------------
cdef void SpatialDB_destructor(void* obj):
  """
  Destroy SpatialDB object.
  """
  # create shim for destructor
  #embed{ void SpatialDB_destructor_cpp(void* pObj)
  spatialdata::spatialdb::SpatialDB* pDB =
    (spatialdata::spatialdb::SpatialDB*) pObj;
  delete pDB;
  #}embed
  SpatialDB_destructor_cpp(obj)
  return

cdef class SpatialDB:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for type of object

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "spatialdata_spatialdb_SpatialDB"
    return


  property label:
    def __set__(self, name):
      """
      Set label of spatial database.
      """
      # create shim for method 'label'
      #embed{ void SpatialDB_label_set(void* pObj, char* name)
      try {
        ((spatialdata::spatialdb::SpatialDB*) pObj)->label(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed

      SpatialDB_label_set(self.thisptr, name)

    def __get__(self):
      """
      Get label of spatial database.
      """
      # create shim for method 'label'
      #embed{ char* SpatialDB_label_get(void* pObj)
      char* label = 0;
      try {
        label = (char*) ((spatialdata::spatialdb::SpatialDB*) pObj)->label();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return label;
      #}embed

      return SpatialDB_label_get(self.thisptr)

      
  def open(self):
    """
    Open database and prepare for querying.
    """
    # create shim for method 'open'
    #embed{ void SpatialDB_open(void* pObj)
    try {
      ((spatialdata::spatialdb::SpatialDB*) pObj)->open();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed

    SpatialDB_open(self.thisptr)
    return


  def close(self):
    """
    Close the database.
    """
    # create shim for method 'close'
    #embed{ void SpatialDB_close(void* pObj)
    try {
      ((spatialdata::spatialdb::SpatialDB*) pObj)->close();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed

    SpatialDB_close(self.thisptr)
    return


  def queryVals(self, names):
    """
    Set values to be returned by queries.
    """
    # create shim for method 'queryVals'
    #embed{ void SpatialDB_queryVals(void* pObj, char** names, int numVals)
    try {
      ((spatialdata::spatialdb::SpatialDB*) pObj)->queryVals((const char**) names, numVals);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed

    cdef char** pNames
    pNames = NULL
    numVals = len(names)
    if numVals > 0:
      pNames = <char**> malloc(numVals*sizeof(char*))
    for i from 0 <= i < numVals:
      strsize = len(names[i])
      pNames[i] = <char*> malloc(1+strsize*sizeof(char))
      tmp = names[i]
      strcpy(pNames[i], tmp)

    SpatialDB_queryVals(self.thisptr, pNames, numVals)

    # memory cleanup
    for i from 0 <= i < numVals:
      free(<void*> pNames[i])
    free(<void*> pNames)
    
    return


  def query(self, locs, cs, nvals):
    """
    Query db to get values at locations.
    """
    # create shim for method 'query'
    #embed{ int SpatialDB_query(void* pObj, double* vals, int nvals, double* coords, int spaceDim, void* csObj)
    int err = 0;
    try {
      spatialdata::geocoords::CoordSys* pCS =
        (spatialdata::geocoords::CoordSys*) csObj;
        err = ((spatialdata::spatialdb::SpatialDB*) pObj)->query(vals, nvals,
                                                            coords, spaceDim,
                                                            pCS);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return err;
    #}embed

    import spatialdata.utils.simplearray
    locs = spatialdata.utils.simplearray.objAsSimpleArray(locs)
    if not locs.isCompatible(nd=2,
                             simpletype="double",
                             contiguous=True,
                             notswapped=True):
      raise TypeError, \
            "Argument 'locs' must be a contiguous, 2-D array of type double."

    if not cs.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument 'cs' must be extension module type 'CoordSys'."
    if nvals < 1:
      raise TypeError, \
              "Argument 'nvals' must be a positive integer."

    (nlocs, spaceDim) = locs.shape
    
    cdef double* pLocs
    pLocs = <double*> PyCObject_AsVoidPtr(locs.data)

    cdef double* pVals
    pVals = doubleArray(nlocs*nvals)

    cdef int* pErr
    pErr = <int*> intArray(nlocs)

    cdef double* valbuffer
    valbuffer = <double*> malloc(nvals*sizeof(double))

    for iloc from 0 <= iloc < nlocs:
      pErr[iloc] = SpatialDB_query(self.thisptr, valbuffer, nvals,
                                  &pLocs[spaceDim*iloc], spaceDim,
                                  ptrFromHandle(cs))
      for ival from 0 <= ival < nvals:
        pVals[nvals*iloc+ival] = valbuffer[ival]
    free(<void*> valbuffer)

    dims = [nlocs, nvals]
    import spatialdata.utils.simplearray
    pValsObj = PyCObject_FromVoidPtr(pVals, NULL);
    pErrObj = PyCObject_FromVoidPtr(pErr, NULL);
    return (spatialdata.utils.simplearray.SimpleCppArray(pValsObj, dims, "double"),
            spatialdata.utils.simplearray.SimpleCppArray(pErrObj, [nlocs], "int"))


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, SpatialDB_destructor)


# ----------------------------------------------------------------------
cdef class GeoGridVelModel(SpatialDB):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* GeoGridVelModel_constructor()
      return (void*)(new yourname::spatialdb::GeoGridVelModel);
    #}embed

    SpatialDB.__init__(self)
    self.thisptr = GeoGridVelModel_constructor()
    self.handle = self._createHandle()
    return


  def filename(self, name):
    """
    Set the filename for velocity model data file.
    """
    # create shim for method 'filename'
    #embed{ void GeoGridVelModel_filename(void* pObj, char* name)
    assert(0 != pObj);
    ((yourname::spatialdb::GeoGridVelModel*) pObj)->filename(name);
    #}embed

    GeoGridVelModel_filename(self.thisptr, name)
    return


# End of file 
